# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **"Умный калькулятор" — основы функций, параметры, return**
    -   **Описание задачи:** Ты разрабатываешь модуль для простых финансовых расчетов. Задача — создать набор независимых функций, каждая из которых выполняет одну четкую операцию и возвращает результат. Это закрепит понимание разницы между `print` и `return`, а также научит строить программу из небольших, переиспользуемых блоков.
    -   **Пример (вход → выход):**
        -   `calculate_discount(1000, 15)` → `850.0`
        -   `calculate_tax(850.0, 20)` → `170.0`
        -   `format_currency(1020.0, "RUB")` → `"1020.0 RUB"`
        -   Граничный случай: `calculate_discount(100, 0)` → `100.0`
    -   **Критерии проверки и ограничения:**
        -   Функции должны только вычислять и возвращать значения. Любой вывод (`print`) должен быть за их пределами.
        -   Использовать только позиционные аргументы.
        -   Результаты должны быть числами (float для денег), кроме функции форматирования, которая возвращает строку.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_discount`, которая принимает `price` и `percent`.
        2.  Вычисли сумму скидки: `price * percent / 100`.
        3.  Верни `price - сумма_скидки`.
        4.  Объяви функцию `calculate_tax`, которая принимает `amount` и `tax_rate`.
        5.  Верни `amount * tax_rate / 100`.
        6.  Объяви функцию `format_currency`, которая принимает `amount` и `currency_code`.
        7.  Верни строку, соединяющую `amount` и `currency_code` через пробел.
    -   **Рекомендации:**
        -   Каждая операция — отдельная функция.
        -   **PEP8:** Имена функций — в `snake_case`, глаголы, отражающие действие (`calculate_...`, `format_...`). После объявления функции оставляй 2 пустые строки.

2.  **"Конфигуратор профиля" — значения по умолчанию и именованные аргументы**
    -   **Описание задачи:** Нужно написать функцию для создания словаря с настройками пользователя. Многие поля не обязательны и имеют стандартные значения. Задача — безопасно реализовать значения по умолчанию для изменяемых типов (списков) и позволить гибко передавать аргументы в любом порядке.
    -   **Пример (вход → выход):**
        -   `create_profile("Максим", age=25)` → `{"name": "Максим", "age": 25, "hobbies": [], "settings": {"theme": "light"}}`
        -   `create_profile("Анна", hobbies=["чтение", "бег"], settings={"theme": "dark", "notifications": False})` → `{"name": "Анна", "age": 18, "hobbies": ["чтение", "бег"], "settings": {"theme": "dark", "notifications": False}}`
        -   Критический случай: два вызова `create_profile("Тест")` должны возвращать независимые списки в поле `hobbies`.
    -   **Критерии проверки и ограничения:**
        -   Параметр `name` обязательный, позиционный.
        -   Параметры `age`, `hobbies`, `settings` — необязательные, с значениями по умолчанию.
        -   Значение по умолчанию для `hobbies` должно быть безопасным (использовать `None`-паттерн).
        -   Функция возвращает словарь.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `create_profile` с параметрами: `name`, `age=18`, `hobbies=None`, `settings=None`.
        2.  Внутри функции: если `hobbies` равен `None`, присвой `hobbies` новый пустой список.
        3.  Если `settings` равен `None`, присвой `settings` новый словарь `{"theme": "light"}`.
        4.  Верни словарь с ключами `"name"`, `"age"`, `"hobbies"`, `"settings"` и соответствующими значениями.
    -   **Рекомендации:**
        -   Для проверки `None` используй оператор `is`.
        -   **PEP8:** Для длинной сигнатуры функции с параметрами по умолчанию можно переносить аргументы на новую строку с отступом.

3.  **"Агрегатор данных" — *args и **kwargs с распаковкой**
    -   **Описание задачи:** Ты пишешь функцию-агрегатор, которая должна уметь обрабатывать произвольное количество числовых данных и произвольные метки (теги) для этих данных. Нужно применить `*args` для сбора чисел и `**kwargs` для сбора мета-информации, а также продемонстрировать распаковку коллекций при вызове.
    -   **Пример (вход → выход):**
        -   `aggregate_data(10, 20, 30, unit="кг", source="весы")` → `{"sum": 60, "count": 3, "unit": "кг", "source": "весы"}`
        -   `aggregate_data(5.5, 2.5)` → `{"sum": 8.0, "count": 2, "unit": "шт", "source": "не указано"}`
        -   С распаковкой:
            ```python
            measurements = [100, 200, 150]
            meta = {"unit": "мл", "experiment": "A"}
            aggregate_data(*measurements, **meta)  # -> {'sum': 450, 'count': 3, 'unit': 'мл', 'experiment': 'A'}
            ```
    -   **Критерии проверки и ограничения:**
        -   Функция должна принимать только `*args` (только числа) и `**kwargs`.
        -   В возвращаемом словаре обязательно должны быть ключи `"sum"` (сумма чисел) и `"count"` (их количество).
        -   Все переданные в `**kwargs` пары ключ-значение должны попасть в возвращаемый словарь.
        -   Обработай случай вызова без аргументов: верни `{"sum": 0, "count": 0}`.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `aggregate_data`, принимающую `*args` и `**kwargs`.
        2.  Посчитай сумму всех элементов в `args`. Посчитай их количество.
        3.  Создай словарь `result` с ключами `"sum"` и `"count"` и вычисленными значениями.
        4.  Добавь в словарь `result` все пары ключ-значение из `kwargs`.
        5.  Верни словарь `result`.
    -   **Рекомендации:**
        -   Для суммирования `args` используй встроенную функцию `sum()`.
        -   **PEP8:** Параметры `*args` и `**kwargs` — общепринятые имена. Если используется только один из них, второй можно опустить.

4.  **"Счетчик операций с изоляцией" — область видимости и структура**
    -   **Описание задачи:** Создай систему, которая умеет создавать независимые счетчики. Каждый счетчик должен хранить свое состояние, и его нельзя изменить извне, кроме как через предоставленную функцию. Это упражнение на понимание локальной области видимости, замыкания и возврата функции как результата.
    -   **Пример (вход → выход):**
        -   ```python
            create_counter_A = make_counter("Счетчик A")
            create_counter_B = make_counter("Счетчик B")

            counterA = create_counter_A()
            counterB = create_counter_B()

            print(counterA()) # -> ("Счетчик A", 1)
            print(counterA()) # -> ("Счетчик A", 2)
            print(counterB()) # -> ("Счетчик B", 1)
            print(counterA()) # -> ("Счетчик A", 3)
            ```
    -   **Критерии проверки и ограничения:**
        -   Функция `make_counter` принимает имя счетчика и возвращает другую функцию (`init_counter`).
        -   Функция `init_counter` при вызове создает и возвращает третью функцию (`counter`).
        -   Функция `counter` при каждом вызове увеличивает внутренний счетчик на 1 и возвращает кортеж `(имя_счетчика, текущее_значение)`.
        -   Нельзя использовать `global`. Состояние (имя и значение счетчика) должно быть защищено внутри замыкания.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `make_counter`, принимающую `name`.
        2.  Внутри `make_counter` объяви функцию `init_counter`.
        3.  Внутри `init_counter` создай локальную переменную `count = 0`.
        4.  Внутри `init_counter` объяви функцию `counter`.
        5.  Внутри `counter` используй нелокальную переменную `count` (или объяви ее как изменяемую, например, список `[0]`) и увеличь ее на 1. Используй `name` из внешней функции `make_counter`.
        6.  Функция `counter` должна вернуть кортеж `(name, count)`.
        7.  Функция `init_counter` должна вернуть функцию `counter`.
        8.  Функция `make_counter` должна вернуть функцию `init_counter`.
    -   **Рекомендации:**
        -   Чтобы изменить переменную из внешней области видимости во вложенной функции, можно использовать трюк с изменяемым объектом (например, список `count = [0]`), либо (если знакомо) ключевое слово `nonlocal`.
        -   **PEP8:** Вложенные функции должны быть отделены от кода внешней функции одной пустой строкой. Используй понятные имена: `make_counter`, `init_counter`, `counter`.
