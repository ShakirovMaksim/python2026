# Практическое задание 35.4

## Задания

### Описание задачи
В предыдущих блоках ты научился создавать функции, передавать аргументы разными способами и использовать `*args` и `**kwargs`. Теперь важно закрепить понимание **области видимости переменных** — границ, в которых переменная доступна для чтения и изменения. В этом задании ты будешь работать с локальными и глобальными переменными, а также с замыканиями, чтобы создать гибкий и безопасный код.

Твоя задача — написать программу для управления простым **счётчиком активности** в системе. Нужно реализовать две функции:
1.  **`create_counter(start=0)`** — функция, которая создаёт и возвращает другую функцию-счётчик. Возвращаемая функция при каждом вызове должна увеличивать своё внутреннее значение на 1 и возвращать новое значение. Начальное значение счётчика задаётся параметром `start`. Это классический пример **замыкания**: внутренняя функция "помнит" значение переменной из внешней функции.
2.  **`global_counter_reset()`** — функция, которая сбрасывает значение **глобальной** переменной `total_operations` (общее количество всех операций со всеми счётчиками) в 0. При этом каждый вызов любого счётчика, созданного `create_counter`, должен увеличивать `total_operations` на 1.

**Контекст:** В реальных системах часто нужно вести несколько независимых счётчиков (например, для разных пользователей или процессов), а также иметь общую статистику по всем операциям. Понимание области видимости (`global` для общей статистики и замыкания для изолированных счётчиков) критически важно для такой архитектуры.

### Пример входных и выходных данных

**Пример 1: Работа с изолированными счётчиками (замыкание)**
```python
# Создаём два независимых счётчика
counter_a = create_counter(start=5)
counter_b = create_counter(start=10)

print(counter_a())  # Счётчик A: 5 + 1 = 6
print(counter_a())  # Счётчик A: 6 + 1 = 7
print(counter_b())  # Счётчик B: 10 + 1 = 11
print(counter_a())  # Счётчик A: 7 + 1 = 8
print(counter_b())  # Счётчик B: 11 + 1 = 12

# Вывод в консоль:
# 6
# 7
# 11
# 8
# 12
```
*Пояснение:* Каждый счётчик хранит своё собственное текущее значение. `counter_a` и `counter_b` не влияют друг на друга, потому что каждое замыкание имеет свою собственную переменную `current`.

**Пример 2: Учёт глобальной статистики**
```python
# total_operations изначально равна 0
print(f"Всего операций до: {total_operations}")  # Должно быть 0

counter_c = create_counter()
print(counter_c())  # 1
print(counter_c())  # 2
print(f"Всего операций после двух вызовов: {total_operations}")  # Должно быть 2

# Сброс глобального счётчика
global_counter_reset()
print(f"Всего операций после сброса: {total_operations}")  # Должно быть 0

print(counter_c())  # 3
print(f"Всего операций после нового вызова: {total_operations}")  # Должно быть 1
```
*Пояснение:* Глобальная переменная `total_operations` увеличивается при каждом вызове любого счётчика. Функция `global_counter_reset` может её обнулить. Обрати внимание, что для изменения глобальной переменной внутри функции `create_counter` и возвращаемого счётчика потребуется ключевое слово `global`.

### Критерии проверки и ограничения
1.  **Обязательные элементы:**
    *   Функция `create_counter` использует **замыкание**. Внутренняя функция должна обращаться к переменной `current`, объявленной во внешней функции.
    *   Для изменения глобальной переменной `total_operations` внутри функций используется ключевое слово `global`.
    *   Функция `global_counter_reset` корректно сбрасывает глобальную переменную `total_operations`.
    *   Начальное значение счётчика (`start`) используется корректно. Первый вызов возвращает `start + 1`.
2.  **Ограничения:**
    *   Нельзя использовать классы (ООП) — только функции и области видимости.
    *   Нельзя использовать изменяемые значения по умолчанию (например, `[]` или `{}`) для параметров функций в этом задании.
    *   Глобальная переменная `total_operations` должна быть определена на уровне модуля (вне всех функций).
3.  **Качество кода:**
    *   Код должен быть читаемым, с осмысленными именами переменных и функций.
    *   Должна быть чёткая граница между локальными переменными в замыкании и глобальной переменной.

### Решение задачи (псевдокод)
1.  **Инициализация:**
    *   В начале программы объяви глобальную переменную `total_operations` и установи её значение в 0.
2.  **Функция `create_counter(start=0)` (создание замыкания):**
    *   Принять параметр `start` (значение по умолчанию 0).
    *   Создать локальную переменную `current`, равную `start`.
    *   Объявить внутреннюю функцию `counter()` (без параметров).
        *   Внутри `counter()` объявить, что переменная `total_operations` является глобальной.
        *   Увеличить `total_operations` на 1.
        *   Увеличить переменную `current` из внешней области видимости на 1.
        *   Вернуть новое значение `current`.
    *   Вернуть функцию `counter` как результат работы `create_counter`.
3.  **Функция `global_counter_reset()`:**
    *   Объявить, что переменная `total_operations` является глобальной.
    *   Установить значение `total_operations` равным 0.

### Рекомендации
*   **Вынести в отдельную функцию:** В этом задании вся логика уже инкапсулирована в функции `create_counter` и `global_counter_reset`. Дополнительное дробление не требуется. Основная цель — практика работы с разными областями видимости в уже заданной структуре.
*   **PEP8:**
    *   Используй `snake_case` для имён функций и переменных (`create_counter`, `global_counter_reset`, `total_operations`).
    *   После объявления функции с помощью `def` оставляй две пустые строки перед следующим объявлением функции или глобальной переменной для лучшей визуальной группировки кода.
