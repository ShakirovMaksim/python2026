# Практическое задание 35.2

Это задание относится ко второму блоку урока, посвященному управлению аргументами. В предыдущем блоке вы научились объявлять функции, передавать аргументы и возвращать значения. Сейчас мы сосредоточимся на использовании значений по умолчанию для параметров, включая безопасную работу с изменяемыми типами данных, а также закрепим правила порядка передачи позиционных и именованных аргументов. Это подготовит вас к более гибкому управлению входными данными функций.

## Задания

### Описание задачи
Вы разрабатываете модуль для управления списком задач в простом планировщике. Нужно создать функцию `add_task`, которая добавляет новую задачу в общий список. Функция должна быть гибкой и безопасной.

**Требования к функции `add_task`:**
1.  Функция принимает три параметра:
    *   `task_list` (список): основной список, в который добавляется задача. Это обязательный позиционный параметр.
    *   `description` (строка): описание задачи. Это обязательный позиционный параметр.
    *   `tags` (список): список тегов (меток) для задачи. Этот параметр должен иметь безопасное значение по умолчанию.
2.  **Критически важное условие:** Значение по умолчанию для параметра `tags` должно быть задано так, чтобы избежать "ловушки изменяемого объекта". Если при вызове не передается список тегов, для задачи должен создаваться новый пустой список.
3.  Функция формирует словарь, представляющий задачу, со следующими ключами: `"description"` и `"tags"`, и добавляет этот словарь в переданный список `task_list`.
4.  Функция ничего не возвращает (т.е., возвращает `None`), а изменяет переданный список.

**Дополнительное задание на порядок аргументов:**
Создайте функцию `create_report`, которая формирует текстовый отчет о задачах.
1.  Функция принимает три параметра:
    *   `task_list` (список): список задач для отчета (обязательный позиционный).
    *   `sort_by_desc` (логическое значение): если `True`, задачи в отчете должны быть отсортированы по описанию (`description`). По умолчанию `False`.
    *   `header` (строка): заголовок отчета. По умолчанию `"Отчет по задачам"`.
2.  Функция должна корректно обрабатывать вызовы как с позиционными, так и с именованными аргументами, соблюдая правильный порядок: сначала позиционные, затем именованные.
3.  Функция возвращает строку — готовый отчет.

### Пример входных и выходных данных

**Работа с функцией `add_task`:**
```python
my_tasks = []  # Исходный список задач

# Вызов 1: Добавление задачи с тегами
add_task(my_tasks, "Купить молоко", ["дом", "срочно"])
print(my_tasks)
# Ожидаемый вывод: [{'description': 'Купить молоко', 'tags': ['дом', 'срочно']}]

# Вызов 2: Добавление задачи без тегов (используется значение по умолчанию)
add_task(my_tasks, "Позвонить маме")
print(my_tasks)
# Ожидаемый вывод: [{'description': 'Купить молоко', 'tags': ['дом', 'срочно']},
#                   {'description': 'Позвонить маме', 'tags': []}]

# Вызов 3: Еще один вызов без тегов. Убедимся, что списки тегов разных задач независимы.
add_task(my_tasks, "Прочитать книгу")
my_tasks[1]["tags"].append("семья")  # Добавим тег только ко второй задаче
print(my_tasks)
# Ожидаемый вывод: [{'description': 'Купить молоко', 'tags': ['дом', 'срочно']},
#                   {'description': 'Позвонить маме', 'tags': ['семья']},
#                   {'description': 'Прочитать книгу', 'tags': []}]
# Важно: тег 'семья' добавился только к задаче "Позвонить маме".
# Задача "Прочитать книгу" осталась с пустым списком тегов, что и требуется.
```

**Работа с функцией `create_report`:**
```python
test_list = [
    {'description': 'Закончить проект', 'tags': ['работа']},
    {'description': 'Записаться к врачу', 'tags': ['здоровье']},
    {'description': 'Апгрейд ПК', 'tags': ['хобби', 'дорого']}
]

# Вызов 1: Все аргументы по порядку (позиционно)
print(create_report(test_list, True, "Важные дела"))
# Ожидаемый вывод (задачи отсортированы по описанию):
# Важные дела
# 1. Апгрейд ПК [хобби, дорого]
# 2. Записаться к врачу [здоровье]
# 3. Закончить проект [работа]

# Вызов 2: Позиционный `task_list` и именованные аргументы в разном порядке
print(create_report(test_list, header="Мой план", sort_by_desc=True))
# Ожидаемый вывод (порядок именованных аргументов не важен, результат тот же):
# Мой план
# 1. Апгрейд ПК [хобби, дорого]
# 2. Записаться к врачу [здоровье]
# 3. Закончить проект [работа]

# Вызов 3: Только обязательный аргумент, остальные — по умолчанию
print(create_report(test_list))
# Ожидаемый вывод (без сортировки, заголовок по умолчанию):
# Отчет по задачам
# 1. Закончить проект [работа]
# 2. Записаться к врачу [здоровье]
# 3. Апгрейд ПК [хобби, дорого]
```

### Критерии проверки и ограничения
1.  Функция `add_task` должна использовать безопасный паттерн (например, с `None`) для значения по умолчанию параметра `tags`, чтобы каждый вызов без указания тегов создавал новый независимый список.
2.  Нельзя использовать темы из будущих блоков: `*args`, `**kwargs`, переменное число аргументов, распаковка, кортеж, словарь (кроме использования словаря как структуры данных для задачи), область видимости, локальная/глобальная переменная, `global`, замыкание, интеграция.
3.  Функция `create_report` должна корректно обрабатывать смешанные вызовы (позиционные + именованные). Попытка передать именованный аргумент перед позиционным должна приводить к ошибке синтаксиса (и так и должно быть в вашем решении).
4.  Отчет должен быть именно строкой, которую возвращает функция, а не просто выводом на печать внутри нее.

### Решение задачи (псевдокод)

**Для функции `add_task`:**
1.  Объяви функцию с параметрами: `task_list`, `description`, `tags` (со значением по умолчанию, безопасным для изменяемого типа).
2.  Внутри функции:
    a.  Если значение параметра `tags` равно специальному безопасному значению по умолчанию, то создать новый пустой список и присвоить его переменной `tags`.
    b.  Создать словарь `new_task` с ключами `"description"` (значение из параметра `description`) и `"tags"` (значение из параметра `tags`, который теперь гарантированно является конкретным списком).
    c.  Добавить словарь `new_task` в конец списка `task_list`.

**Для функции `create_report`:**
1.  Объяви функцию с параметрами: `task_list`, `sort_by_desc` (со значением по умолчанию `False`), `header` (со значением по умолчанию `"Отчет по задачам"`).
2.  Внутри функции:
    a.  Создать копию списка `task_list` для работы (например, через `list(task_list)`), чтобы не менять исходный список. Присвоить ее переменной `work_list`.
    b.  Если `sort_by_desc` равно `True`, отсортировать `work_list` по значению ключа `"description"` в каждом словаре.
    c.  Начать формировать результирующую строку `report_text` с заголовка (значение параметра `header`) и символа переноса строки.
    d.  Для каждой задачи в отсортированном (или нет) списке `work_list`:
        i.   Получить описание и список тегов.
        ii.  Преобразовать список тегов в строку, например, соединив элементы запятой.
        iii. Добавить к `report_text` строку в формате `"{номер}. {описание} [{теги}]"` и символ переноса строки. Номер задачи — это индекс в списке `work_list` плюс 1.
    e.  Вернуть строку `report_text`.

### Рекомендации
-   Вынести в отдельную функцию: Само задание уже требует создания двух функций (`add_task` и `create_report`). Дополнительно внутри `create_report` можно выделить в небольшую вспомогательную функцию логику форматирования одной задачи в строку, но это не обязательно.
-   PEP8:
    -   Используйте осмысленные имена переменных и параметров (`task_list`, `description`, `tags`), которые соответствуют их назначению.
    -   После определения функции оставляйте две пустые строки перед следующим блоком кода (например, перед следующим определением функции или основным кодом). Внутри функции отделяйте логические блоки одной пустой строкой.
