# Задание 33.2. Генераторы коллекций. list, dict, set comprehensions

## Блок урока
«List comprehensions» позволяет собирать новые списки из нескольких источников данных без промежуточных структур и при этом сохранять читаемость.

## Условие задачи
**Сложность**: <span style="color: #c62828">● сложный</span>. примерное время: 15–20 минут

Есть два списка: `tracks` с парами `(исполнитель, название)` и `plays` с кортежами `(название, прослушивания)`. Построй одним list comprehension список строк `"Исполнитель — Название (N прослушиваний)"` только для треков, у которых число прослушиваний больше среднего по списку `plays`. Считай, что в `plays` названия уникальны.

## Пример входных данных
```
tracks = [
    ("Imagine Dragons", "Believer"),
    ("Muse", "Uprising"),
    ("Daft Punk", "Harder Better")
]
plays = [
    ("Believer", 95),
    ("Uprising", 70),
    ("Harder Better", 110)
]
```

## Пример выходных данных
```
['Imagine Dragons — Believer (95 прослушиваний)', 'Daft Punk — Harder Better (110 прослушиваний)']
```

## Критерии успешного выполнения
- Вся логика реализована одним выражением list comprehension.
- Среднее значение считается один раз и используется внутри выражения.
- В результат попадают только треки, у которых есть запись в `plays`.
- Формат строки строго соответствует образцу с длинным тире.

## Подсказки
- Предварительно вычисли среднее через `sum(...) / len(plays)`.
- Используй вложенный генератор или словарь для быстрого поиска количества прослушиваний.

## Частые ошибки и ограничения
- Дублирование строк из-за отсутствия проверки названия.
- Многократный пересчёт среднего в comprehension замедляет код.
- Изменение исходных списков нарушает условие.
